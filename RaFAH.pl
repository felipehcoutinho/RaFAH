#! /usr/bin/perl
use warnings;
use strict;
use Getopt::Long;
use Bio::SeqIO;
use Bio::SearchIO;

my $train; #Flag to train user custom models
my $predict; #Flag to perform prediction
my $fetch; #Flag to fetch raw data used to train the default models
my $file_prefix = "RaFAH"; #String to be added as prefix of the output files
my $suffix = "";
my $start_stage; #Stage of analysis to start from
my $genomes_dir; #Directory where the fasta file of the genomes to be analysed are located
my $out_dir = "./"; #Directory to store the output files
my $merged_cds_file_name; #Directory where the fasta file of the CDS (protein sequences0 derived from the genomes to be analysed are located
my $extension = "fasta"; #extension of files to be processed
my $hmmer_hits_file_name; #Hmmsearch output file generated by querying the hmmer models against the CDS (protein sequences) from the genomes to be analysed
my $genomexog_table_file_name; #Genome x OG tsv format table describing the unique score of each hmmer model to each genome
my $threads = 1; #Number of threads to use during analysis
my $true_host;

my $max_evalue = 0.00001; #Maximum evalue to consider a match between a hmmer model and a protein sequence when parsing the hmmsearch file
my $min_score = 50; #Minimum score to consider a match between a hmmer model and a protein sequence when parsing the hmmsearch file
my $min_cutoff = 0.14; #Minimum score provided by the RF to consider a host prediction when parsing the host prediction scores file

#Change the location of the files below to point to the default RaFAH model files or to your custom generated models
my $valid_ogs_file = "/home/felipe/felipe/Databases/RefSeqVir_Oct_19/RF_Host_Pred/External_Validation_Set/MMSeqs_Clusters/Filtered_0.9_OGs/HP_Ranger_Model_3_Valid_Cols.txt";
my $hmmer_db_file_name = "/home/felipe/felipe/Databases/RefSeqVir_Oct_19/RF_Host_Pred/External_Validation_Set/MMSeqs_Clusters/Hmm_Files/HP_Ranger_Model_3_Filtered_0.9_Valids.hmm";
my $r_script_predict_file_name = "/home/felipe/felipe/Scripts/RaFAH_Predict_Host.R";
my $r_script_train_file_name = "/home/felipe/felipe/Scripts/RaFAH_Train_Model.R";
my $r_model_file_name = "/home/felipe/felipe/Databases/RefSeqVir_Oct_19/RF_Host_Pred/External_Validation_Set/MMSeqs_Clusters/Filtered_0.9_OGs/MMSeqs_Clusters_Ranger_Model_1+2+3_Clean.RData";


my $help;
my $parse_only;
my $version;

GetOptions(
'train' => \$train,
'predict' => \$predict,
'fetch' => \$fetch,
'file_prefix=s' => \$file_prefix,
'genomes_dir=s' => \$genomes_dir,
'output_dir=s' => \$out_dir,
'merged_cds_file_name=s' => \$merged_cds_file_name,
'extension=s' => \$extension,
'threads=s' => \$threads,
'hmmer_hits_file_name=s' => \$hmmer_hits_file_name,
'genomexog_table_file_name=s' => \$genomexog_table_file_name,
'valid_ogs_file=s' => \$valid_ogs_file,
'hmmer_db_file_name=s' => \$hmmer_db_file_name,
'r_script_predict_file_name=s' => \$r_script_predict_file_name,
'r_script_train_file_name=s' => \$r_script_train_file_name,
'r_model_file_name=s' => \$r_model_file_name,
'min_cutoff=s' => \$min_cutoff,
'true_host=s' => \$true_host,
'help' => \$help,
'version' => \$version,
'parse_only' => \$parse_only
);

$file_prefix = $out_dir."/".$file_prefix;

#Global variables not set by the user
my $merged_genomes_file_name;
my $host_pred_file_name = $file_prefix."_Host_Predictions.tsv";
my $mmseqs_index_file = $file_prefix."_MMSeqs_Training_cluster.tsv";

#Version info
die "Version 0.3" if ($version);

#Help message
die "
RaFAH Random Forest Assignment of Hosts
Version 0.3

    Copyright (C) 2021  Felipe Hernandes Coutinho (felipehcoutinho\@gmail.com)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or trainNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.


	
Usage:
--help | Print this help message and exit.
--file_prefix | String to be added to the output files (Default: RaFAH).
--predict | Run the host prediction mode using a pre-computed model
--train | Run the model trainting mode to generate a custom model
--fetch | Download the default pre-computed model files
--threads | Number of threads to be used during analysis (Default: 1).

\tHost Prediction criteria:
--min_cutoff | Minimum score to consider a host prediction as valid (Default: 0.14).

\tInput files for host prediction:
--genomes_dir | Directory containing DNA sequences of viral genomes to be analyzed in FASTA format.
--extension | Extension of the FASTA files containing the DNA sequences of viral genomes to be analyzed (e.g. fasta, fna, fsa) | Default: fasta
--merged_cds_file_name | Fasta extension file containing protein sequences derived from viral genomes.\n\\tSequences MUST be named as the Id of the original genomic sequence followed by _SEQNUM. \n\tExample: Scaffold_1_1, Scaffold_1_2, Scaffold_1_3, GenomeA_1, GenomeA_2...
--hmmer_hits_file_name | Output file generated by querying the Hmmer DB files against the identified/provided protein sequences using hmmsearch.
--genomexog_table_file_name | Genome x OGs .tsv format table describing the best-hit score of each hmmer model to each viral genome
--valid_ogs_file | List of valid ogs used by a specific model file
--r_model_file_name | R data file containing the pre-computed RF for a specific model (.RData extension)
--r_script_predict_file_name | R script used to perform host predictions (.R extension)
You must provide --genomes_dir and --extension OR --merged_cds_file_name OR --hmmer_hits_file_name OR --genomexog_table_file_name.

\tInput files for training your own model:
--genomes_dir | Directory containing DNA sequences of viral genomes to be analyzed in FASTA format.
--extension | Extension of the FASTA files containing the DNA sequences of viral genomes to be analyzed (e.g. fasta, fna, fsa) | Default: fasta
--merged_cds_file_name | Fasta extension file containing protein sequences derived from viral genomes.\n\\tSequences MUST be named as the Id of the original genomic sequence followed by _SEQNUM. \n\tExample: Scaffold_1_1, Scaffold_1_2, Scaffold_1_3, GenomeA_1, GenomeA_2...
--hmmer_hits_file_name | Output file generated by querying the Hmmer DB files against the identified/provided protein sequences using hmmsearch.
--genomexog_table_file_name | Genome x OGs .tsv format table describing the best-hit score of each hmmer model to each viral genome
--true_host | Genome (First column) X Host Taxon (Second column) .tsv format table
You must provide --true_host and one of: --genomes_dir and --extension OR --merged_cds_file_name OR --hmmer_hits_file_name OR --genomexog_table_file_name.


Dependencies for performing host predictions using pre-computed models:
BioPerl
Prodigal (v2.60)
HMMER (v3.1b2)
R (v3.6.3)
R libraries: ranger

Dependencies for trainting custom models:
BioPerl
Prodigal (v2.60)
MMSeqs2 (Release 12-113e3)
MUSCLE (v3.8.1551)
HMMER (v3.1b2)
R (v3.6.3)
R libraries: ranger
" if $help;

my %seq_info;
my %valids_list;
my %hmmer_scores;

central();
exit 0;

sub central {
	if ($predict) {
		print "Running host prediction mode\n";
		$suffix = "_Prediction";
		define_stage();
		create_output_folder();
		merge_and_index_genomes($genomes_dir) if ($start_stage <= 1); 
		call_prodigal($merged_genomes_file_name) if ($start_stage <= 1);
		index_cds_seqs($merged_cds_file_name) if ($start_stage <= 2);
		call_hmmscan($merged_cds_file_name,$hmmer_db_file_name) if ($start_stage <= 2);
		calc_scores($hmmer_hits_file_name) if ($start_stage <= 3);
		predict_host($genomexog_table_file_name) if ($start_stage <= 4);
		print_results();
	} elsif ($train) {
		print "Running custom model training mode\n";
		$suffix = "_Training";
		define_stage();
		create_output_folder();
		merge_and_index_genomes($genomes_dir) if ($start_stage <= 5); 
		call_prodigal($merged_genomes_file_name) if ($start_stage <= 5);
		index_cds_seqs($merged_cds_file_name) if ($start_stage <= 6);
		cluster_cds_seqs($merged_cds_file_name) if ($start_stage <= 6);
		build_hmms($merged_cds_file_name,$mmseqs_index_file) if ($start_stage <= 6);
		call_hmmscan($merged_cds_file_name,$hmmer_db_file_name) if ($start_stage <= 7);
		read_true_host() if ($start_stage <= 8);
		calc_scores($hmmer_hits_file_name) if ($start_stage <= 8);
		train_model($genomexog_table_file_name) if ($start_stage <= 9);
		print_results();
	} elsif ($fetch) {
		print "Downloading default model files\n";
		fetch_data();
	} else {
		print "run RaFAH.pl --help for instructions\n";
	}
}

sub create_output_folder {
	if (-d $out_dir) {
		print "Warning! $out_dir already exists. Will overwrite previous files.\n";
	} else {
		system("mkdir $out_dir");
	}
}

sub fetch_data {
	print "Downloading default hmmer models\n";
	system("wget https://sourceforge.net/projects/rafah/files/RaFAH_v0.1_Files/RaFAH_v0.1_hmm_models.tgz");
	print "Decompressing default hmmer models\n";
	system("tar -zxvf RaFAH_v0.1_hmm_models.tgz");
	system("rm -f RaFAH_v0.1_hmm_models.tgz");
	print "Downloading default RF model\n";
	system("wget https://sourceforge.net/projects/rafah/files/RaFAH_v0.1_Files/RaFAH_v0.1_Ranger_Model.tgz");
	print "Decompressing default RF model\n";
	system("tar -zxvf RaFAH_v0.1_Ranger_Model.tgz");
	system("rm -f RaFAH_v0.1_Ranger_Model.tgz");
	print "Downloading list of valid OGs for default model\n";
	system("wget https://sourceforge.net/projects/rafah/files/RaFAH_v0.1_Files/HP_Ranger_Model_3_Valid_Cols.txt");
	print "Downloading host prediction script\n";
	system("wget https://sourceforge.net/projects/rafah/files/RaFAH_v0.2_Files/RaFAH_Predict_Host.R");
	print "Downloading custom model training script";
	system("wget https://sourceforge.net/projects/rafah/files/RaFAH_v0.2_Files/RaFAH_Train_Model.R");
}


sub read_true_host {
	print "Reading true host data from $true_host\n";
	open IN, "< $true_host" or die "$!";
	my $counter = 0;
	while (my $line = <IN>) {
		$line =~ s/\r//g;
		chomp $line;
		$counter++;
		my ($id,$host) =  split /\t/, $line;
		$seq_info{"Host"}{$id} = $host;
	}
	close IN;
	print "Read host data for $counter sequences\n";
}
sub define_stage {
	if ($predict) {
		#This subroutine defined the sateg of analysis to start based on the files provided by the user
		$start_stage = 1 if (defined $genomes_dir);
		$start_stage = 2 if (defined $merged_cds_file_name);
		$start_stage = 3 if (defined $hmmer_hits_file_name);
		$start_stage = 4 if (defined $genomexog_table_file_name);
	} elsif ($train) {
		$start_stage = 5 if (defined $genomes_dir);
		$start_stage = 6 if (defined $merged_cds_file_name);
		$start_stage = 8 if (defined $hmmer_hits_file_name);
		$start_stage = 9 if (defined $genomexog_table_file_name);
	}
	#If none of the necessary files are provided the program dies with a message
	die "Must provide at least one of: --genomes_dir, --merged_cds_file_name --hmmer_hits_file_name, --genomexog_table_file_name\n" unless ((defined $start_stage) and ($start_stage >= 1));
}

sub train_model {
	print "Training custom model\n";
	my $out_model_file = $file_prefix."_Model".$suffix.".RData";
	my $importance_file = $file_prefix."_Importance_Matrix".$suffix.".tsv";
	my $confusion_file = $file_prefix."_Confusion_Matrix".$suffix.".tsv";
	system("Rscript $r_script_train_file_name $out_model_file $genomexog_table_file_name $threads $confusion_file $importance_file");
}

sub build_hmms {
	print "Building hmm models\n";
	my $cds_file = $_[0];
	my $index_file = $_[1];
	my %seq2og;
	my %og_info;
	open IN, "< $index_file" or die "$!";
	while (my $line = <IN>) {
		chomp $line;
		my ($og,$cds) =  split /\t/, $line;
		$seq2og{$cds} = $og;
		$og_info{"CDS_Count"}{$og}++;
	}
	close IN;
	
	my $og_dir = $file_prefix."_OGs".$suffix;
	system("mkdir $og_dir") unless ($parse_only);
	my $ali_dir = $file_prefix."_Aligned_OGs".$suffix;
	system("mkdir $ali_dir") unless ($parse_only);
	my $hmm_dir = $file_prefix."_hmm_OGs".$suffix;
	system("mkdir $hmm_dir") unless ($parse_only);
	
	my $seq_in = Bio::SeqIO->new('-file' => "< $merged_cds_file_name", '-format' => "Fasta");
	my $counter = 0;
	my %print_count;
	while (my $seq_obj = $seq_in->next_seq) {
			$counter++;
			my $id = $seq_obj->id();
			my $og = $seq2og{$id};
			if ($og_info{"CDS_Count"}{$og} >= 3) {
				my $out_name = $file_prefix."_OG_".$og.$suffix.".faa";
				my $seq_out = Bio::SeqIO->new('-file' => ">> $out_name", '-format' => "Fasta")  unless ($parse_only);
				$seq_out->write_seq($seq_obj) unless ($parse_only);
				$print_count{$og}++;
				if ($print_count{$og} == $og_info{"CDS_Count"}{$og}) {
					system("muscle -in $out_name -out Aligned_$out_name") unless ($parse_only);
					system("hmmbuild -n $og Aligned_$out_name.hmm Aligned_$out_name") unless ($parse_only);
					system("mv $out_name $og_dir/")  unless ($parse_only);
					system("mv Aligned_$out_name $ali_dir/") unless ($parse_only);
					system("mv Aligned_$out_name.hmm $hmm_dir/") unless ($parse_only);
				}
			}
		}
		
	$hmmer_db_file_name = $file_prefix."_Merged".$suffix.".hmm";
	system("cat $hmm_dir/Aligned_*hmm > $hmmer_db_file_name") unless ($parse_only);
	system("hmmpress $hmmer_db_file_name") unless ($parse_only);
}

sub cluster_cds_seqs {
	print "Performing CDS clustering\n";
	my $cds_file = $_[0];
	my $mmseqs_output = $file_prefix."_MMSeqs_Training";
	system("mmseqs easy-cluster $cds_file $mmseqs_output tmp_Cluster --threads $threads -c 0.7 -s 7.5 --min-seq-id 0.35 --cov-mode 0") unless ($parse_only);
}

sub predict_host {
	print "Performing host prediction\n";
	system("Rscript $r_script_predict_file_name $r_model_file_name $genomexog_table_file_name $host_pred_file_name $threads");
	print "Parsing output of host prediction $host_pred_file_name\n";
	open INPUT, "< $host_pred_file_name" or die "$!";
	my $header = <INPUT>;
	while (my $line = <INPUT>) {
		chomp $line;
		my @values = split /\t/, $line;
		my $genome = $values[0];
		my $predicted_host_name = $values[1];
		my $predicted_host_score = $values[2];
		if ($predicted_host_score >= $min_cutoff) {
			$seq_info{"Predicted_Host"}{$genome} = $predicted_host_name;
			$seq_info{"Predicted_Host_Score"}{$genome} = $predicted_host_score;
		}
	}
	close INPUT;
}


sub calc_scores {
	my $hits_file = $_[0];
	my %seen_queries;
	my %seen_scaffolds;
	
	if ($predict) {
		#Read the list of valid ogs (i.e. those that MUST be in the Genome x OG table) 
		open INPUT, "< $valid_ogs_file" or die "$!";
		while (my $line = <INPUT>) {
			chomp $line;
			my @values = split /\t/, $line;
			$valids_list{$values[0]} = 1;
		}
		close INPUT;
		my $valids_count = keys %valids_list;
		print "Obtained $valids_count ids from $valid_ogs_file\n";
	}
	
	print "Parsing $hits_file\n";
	#Parse the hmmsearch output 
	my $in = Bio::SearchIO->new( -file => $hits_file, -format => 'hmmer' );
	while ( my $result = $in -> next_result ) {
		 while( my $hit = $result->next_hit ) {
			while( my $hsp = $hit->next_hsp ) {            
				my $hit_desc = $hit->description;
				my $evalue = $hsp->evalue;
				my $score = $hsp->score;
				next if ($evalue > $max_evalue);
				next if ($score < $min_score);

				my $func = $hit->name;#." (".$hit_desc.")";
				my $query = $result->query_name();
				my $query_desc = $result->query_description();
				
				if ($predict) {
					next unless (defined $valids_list{$query});
				}
				
				my $scaffold = $func;
				$scaffold =~ s/_(\d)+$//;
				$scaffold =~ s/-cds(\d)+$//;
				
				if ($train) {
					#my $scaffold_no_version = $scaffold;
					#$scaffold_no_version =~ s/\.(\d)$//;
					die "No host defined for $scaffold!\n" unless (defined $seq_info{"Host"}{$scaffold});
					$hmmer_scores{"Host"}{$scaffold} = $seq_info{"Host"}{$scaffold};
				}
				
				$seen_queries{$query} = 1;
				$seen_scaffolds{$scaffold} = 1;
				
				$hmmer_scores{$query}{$scaffold} = $score unless (defined $hmmer_scores{$query}{$scaffold});
				
				if ($score > $hmmer_scores{$query}{$scaffold}) {
					$hmmer_scores{$query}{$scaffold} = $score;
				}
				
				}
			}
		}
	
	$genomexog_table_file_name = $file_prefix."_"."Genome_to_OG_Score_Min_Score_$min_score-Max_evalue_$max_evalue".$suffix.".tsv";
	my %params = ("matrix" => \%hmmer_scores, "file" => $genomexog_table_file_name, "missing" => "0");
	
	my $seen_query_count = keys %seen_queries;
	
	if ($train) {
		print "Printing list of valid OGs\n";
		$valid_ogs_file = $file_prefix."_"."Valid_OGs".$suffix.".tsv";
		open OUT, "> $valid_ogs_file" or die "$!";
		foreach my $og (keys %seen_queries) {
			print OUT "$og\n";
		}
		close OUT;
	}
	
	my $seen_scaffold_count = keys %seen_scaffolds;
	print("Detected $seen_query_count OGs across $seen_scaffold_count genomic sequences\n");
	
	if ($predict) {
		print_matrix_valids(\%params);
	} elsif ($train) {
		print_matrix(\%params)
	}
}

sub print_results {
	my $seq_info_file_name = $file_prefix."_Seq_Info".$suffix.".tsv";
	print "Printing results to $seq_info_file_name\n";
	my %params = ("matrix" => \%seq_info, "file" => $seq_info_file_name);
	print_matrix(\%params);
}

sub merge_and_index_genomes {
	my $genomes_dir = $_[0];
	print "Indexing sequences from $genomes_dir\n";
	#Iterate over all fasta file
	my @files = glob("$genomes_dir/*$extension");
	#Count number of sequences seen
	my $counter = 0;
	#Run through all fasta files and print all sequences to $_[0]
	$merged_genomes_file_name = $file_prefix."_Genomes".$suffix.".fasta";
	my $seq_out = Bio::SeqIO->new(-file => "> $merged_genomes_file_name", -extension => "fasta");

	foreach my $file (@files) {
		my $file_name = $file;
		$file_name =~ s/(.)*\///;
		print "Processing $file_name\n";
		my $seq_in = Bio::SeqIO->new(-file => "< $file", -extension => "fasta");
		while (my $seq_obj = $seq_in->next_seq) {
			$counter++;
			my $seq_id = $seq_obj->id;
			my $seq_length = $seq_obj->length;
			my $seq_desc = $seq_obj->desc;
			die "Repeated id $seq_id in $file\n" if (defined $seq_info{"Original_File"}{$seq_id});
			$seq_info{"Original_File"}{$seq_id} = $file_name;
			$seq_info{"Description"}{$seq_id} = $seq_desc;
			$seq_info{"Length"}{$seq_id} = $seq_length;
			$seq_out->write_seq($seq_obj);
		} 
	}	
	print "Processed $counter Genomic Sequences\n";
}


sub call_hmmscan {
	my $cds_file = $_[0];
	my $db_file = $_[1];
	print "Running hmmsearch. Query: $cds_file DB: $db_file\n";
	$hmmer_hits_file_name = $file_prefix."_CDSxClusters".$suffix;
	system("hmmsearch -o $hmmer_hits_file_name --noali --cpu $threads $db_file $cds_file") unless ($parse_only);
}

sub index_cds_seqs {
	print "Indexing sequences from $merged_cds_file_name\n";
	my %seen_ids;
	my $seq_in = Bio::SeqIO->new('-file' => "< $merged_cds_file_name", '-extension' => "Fasta");
	my $counter = 0;
	while (my $seq_obj = $seq_in->next_seq) {
			$counter++;
			my $id = $seq_obj->id();
			die "Repeated id for sequence #$counter. Id: $id in $merged_cds_file_name\n" if (defined $seen_ids{$id});
			$seen_ids{$id} = 1;
			my $genome = $id;
			$genome =~ s/_(\d)+$//;
			$genome =~ s/-cds(\d)+$//;
			$seq_info{"CDS_Count"}{$genome}++;
		}	
}
	
sub call_prodigal {
    my $merged_genomes_file_name = $_[0];
	$merged_cds_file_name = $file_prefix."_CDS".$suffix.".faa";
	my $merged_gene_file_name = $file_prefix."_CDS".$suffix.".fna";
	my $merged_gff_file_name = $file_prefix."_CDS".$suffix.".gff";
	print "Running Prodigal\n";
	system("prodigal -q -n -p meta -a $merged_cds_file_name -d $merged_gene_file_name -f gff -i $merged_genomes_file_name -o $merged_gff_file_name") unless ($parse_only);
}


sub read_table {
#Reads a table as a 2D hash. Columns are the first dimension and rows the second. Receives a reference of a hash as the parameters to run the subroutine  
	my %parameters	= %{$_[0]};
	die "No Input File Defined.\n" unless (defined $parameters{"file"});
	my $file = $parameters{"file"};
	my $sep = "\t";
	$sep = $parameters{"separator"} if (defined $parameters{"separator"});	
	
	my %matrix;

	open INPUT, "< $file" or die "$!";
	my $header = <INPUT>;
	$header =~ s/\r$//;
	chomp $header;
	my @cols = split /$sep/, $header;
	
	my $values_count;
	while (my $line = <INPUT>) {
		#Read each line and assign it to the 2D hash
		$line =~ s/\r$//;
		chomp $line;
		my @rows = split /$sep/, $line;
		foreach my $posit (1..(@cols - 1)) {
			$matrix{$cols[$posit]}{$rows[0]} = $rows[$posit];
			$values_count++;
		}
	}
	close INPUT;
	print "Obtained $values_count values from $file.\n";
	return \%matrix;
}


sub print_matrix {
    my %parameters  = %{$_[0]};
         
    die "No Matrix (2D Hash) Defined.\n" unless (defined $parameters{"matrix"});
    my %matrix = %{$parameters{"matrix"}};  
    my $output_file = "Output_Matrix";
    my $sep = "\t"; 
    my $missing = "NA";
	
	$missing = $parameters{"missing"} if (defined $parameters{"missing"});
    $output_file = $parameters{"file"} if (defined $parameters{"file"});
    $sep = $parameters{"separator"} if (defined $parameters{"separator"});      
	
     
    my $rows_ref = list_level2(\%matrix);
    my %rows = %{$rows_ref};
 
    open OUTPUT, "> $output_file" or die "$!";   
    print OUTPUT "Variable";
    #print the Header   
    foreach my $col (sort keys %matrix) {
        print OUTPUT "$sep"."$col";
        }
    print OUTPUT "\n";
    #print the row names followed by the values and a line break
    foreach my $row (sort keys %rows) {
        print OUTPUT "$row";
        foreach my $col (sort keys %matrix) {
            if (defined $matrix{$col}{$row}) {print OUTPUT "$sep"."$matrix{$col}{$row}"} else {print OUTPUT "$sep"."$missing"};
        }
    print OUTPUT "\n";
    }
    close OUTPUT;
}
 
sub list_level2 {
    #Receives a reference to a 2D hash. returns a reference to a 1D hash in which the keys are all the keys from the 2nd dimesion of the input hash 
    my %hash = %{$_[0]};
    my %list;   
    foreach my $param1 (keys %hash) {
		my %hash2 = %{$hash{$param1}};
        foreach my $param2 (keys %hash2) {
            $list{$param2} = 1;
        }
    }
    return \%list;
}


sub print_matrix_valids {
    my %parameters  = %{$_[0]};
         
    die "No Matrix (2D Hash) Defined.\n" unless (defined $parameters{"matrix"});
    my %matrix = %{$parameters{"matrix"}};  
    my $output_file = "Output_Matrix";
    my $sep = "\t"; 
     
    $output_file = $parameters{"file"} if (defined $parameters{"file"});
    $sep = $parameters{"separator"} if (defined $parameters{"separator"});      
 
     
    my $rows_ref = list_level2(\%matrix);
    my %rows = %{$rows_ref};
 
    open OUTPUT, "> $output_file" or die "$!";   
    print OUTPUT "Sequence";
	my @sorted_cols = sort keys %valids_list;
	
    #print the Header   
    foreach my $col (@sorted_cols) {
        print OUTPUT "$sep"."$col";
        }
    print OUTPUT "\n";
    #print the row names followed by the values and a line break
    foreach my $row (sort keys %rows) {
		#next unless (defined $seq_info{"Length"}{$row});
        print OUTPUT "$row";
        foreach my $col (@sorted_cols) {
            if (defined $matrix{$col}{$row}) {
				print OUTPUT "$sep"."$matrix{$col}{$row}";
			}  else {
				print OUTPUT "$sep"."0";
			}
        }
    print OUTPUT "\n";
    }
    close OUTPUT;
}
